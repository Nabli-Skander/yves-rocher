"use strict";function _typeof(r){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r})(r)}!function(n){var t={};function i(r){if(t[r])return t[r].exports;var e=t[r]={i:r,l:!1,exports:{}};return n[r].call(e.exports,e,e.exports,i),e.l=!0,e.exports}i.m=n,i.c=t,i.d=function(r,e,n){i.o(r,e)||Object.defineProperty(r,e,{enumerable:!0,get:n})},i.r=function(r){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})},i.t=function(e,r){if(1&r&&(e=i(e)),8&r)return e;if(4&r&&"object"===_typeof(e)&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var t in e)i.d(n,t,function(r){return e[r]}.bind(null,t));return n},i.n=function(r){var e=r&&r.__esModule?function(){return r.default}:function(){return r};return i.d(e,"a",e),e},i.o=function(r,e){return Object.prototype.hasOwnProperty.call(r,e)},i.p="",i(i.s="./src/static/js/intersection-observer-script.js")}({"./src/static/js/intersection-observer-script.js":function srcStaticJsIntersectionObserverScriptJs(module,exports){eval("// Inspiré de https://www.smashingmagazine.com/2018/01/deferring-lazy-loading-intersection-observer-api/\r\n\r\n// Polyfill pour forEach pour IE 8 à 11\r\nif (window.NodeList && !NodeList.prototype.forEach) {\r\n    NodeList.prototype.forEach = function (callback, thisArg) {\r\n        thisArg = thisArg || window;\r\n        for (var i = 0; i < this.length; i++) {\r\n            callback.call(thisArg, this[i], i, this);\r\n        }\r\n    };\r\n}\r\n\r\n// Fonction de préchargement d'image\r\nfunction preloadImage(img) {\r\n  const src = img.getAttribute('data-src');\r\n  const srcset = img.getAttribute('data-srcset');\r\n  if(!src) {\r\n    return;\r\n  }\r\n  img.src = src;\r\n  \r\n  if(!srcset) {\r\n    return;\r\n  }\r\n  img.srcset = srcset;\r\n}\r\n\r\n// Configuration de l'observer (optionnel)\r\nconst config = {\r\n  rootMargin: '0px 0px 500px 0px',\r\n  threshold: 0\r\n};\r\n\r\n// Instanciation de l'intersectionObserver pour le lazy loading\r\nlet observer = new IntersectionObserver(function(entries, self) {\r\n  // Pour chaque entrée ciblée (les images ici)\r\n  entries.forEach(entry => {\r\n    // L'API Javascript vérifie que l'entrée existe...\r\n    if(entry.isIntersecting) {\r\n      // Modifie la data-src en src avec une fonction preloadImage()\r\n      preloadImage(entry.target);\r\n      \r\n      // L'image est chargée, l'API peut s'arrêter jusqu'à la prochaine, etc.\r\n      self.unobserve(entry.target);\r\n    }\r\n  });\r\n}, config);\r\n\r\n// Sélectionne les images et lance l'observer asynchrone\r\nconst images = document.querySelectorAll('[data-src]');\r\nimages.forEach(img => {\r\n  // Observation des images à charger au fur et à mesure\r\n  observer.observe(img);\r\n});\r\n\r\n// Instanciation de l'intersectionObserver pour le lazy loading\r\nlet backgroundObserver = new IntersectionObserver(function(entries, self) {\r\n  // Pour chaque entrée ciblée (les images ici)\r\n  entries.forEach(entry => {\r\n    // L'API Javascript vérifie que l'entrée existe...\r\n    if(entry.isIntersecting) {\r\n      // Ajoute une classe visible pour afficher la bonne image\r\n      entry.target.classList.add(\"visible\");\r\n      \r\n      // L'image est chargée, l'API peut s'arrêter jusqu'à la prochaine, etc.\r\n      self.unobserve(entry.target);\r\n    }\r\n  });\r\n}, config);\r\n\r\n// Même travail pour les images en background\r\nconst bckgImages = document.querySelectorAll('.bckg-img');\r\nbckgImages.forEach(img => {\r\n  // Observation des images à charger au fur et à mesure\r\n  backgroundObserver.observe(img);\r\n});\n\n//# sourceURL=webpack:///./src/static/js/intersection-observer-script.js?")}});
//# sourceMappingURL=script.js.map
